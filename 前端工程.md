##### 最近看到一篇文章,讲的是如何构建高质量的前端工程代码?

+ **什么是高质量的工程代码？**

> 高质量的工程代码， 并不等价于性能最优，技术最新，复用性最强的技术选型。回顾几年前的前端领域：JQuery 时代，虽然要手动操作 DOM，但其实在那时， Google Closure 和 Ext.js 团队就已经提供了完整的组件化概念，甚至 Ext.js 还提供了组件冒泡这样的创新事件机制。那时用 Zepto 维护的代码，编码速度甚至比现在写一些 React 项目还要快。不同的技术只是工具，怎么用工具，能把工具用到什么程度，最终取决于开发者自身，所以高质量的工程代码，更多应该从业务和工程的角度考虑问题，而非技术选型。

> 举个例子，当整个公司都在使用 React 开发时，虽然我们知道 Vue 使用可能会更简单便捷，但我们一定不会去用，因为这个时候，虽然看起来写代码更简单了，但其他人在 React 方向沉淀的经验，你无法复用，额外还需要整个团队去学习一套全新的技术，这样的工程设计，在这个背景下，显然是不合理的。

> Thenewstack 做过 2019 年的开发者数据统计，开发者 32% 的时间用于业务开发，19% 的时间在维护代码，也就是工程师真正能投入到研发中的时间也只有工作时间的一半。对于开发者来说，这个时候通过合理的代码设计，提升代码的可扩展性，可维护性， 降低开发和维护代码的时间，才是最强的诉求。

> 所以，高质量的工程代码应该是结合业务与团队情况，真正能够提升研发效率，降低项目维护成本的代码。

以前我觉得什么是高质量代码 : 
  1. 简洁且规范, 代码阅读起来不费劲
  2. 尽可能多且完成注释, 帮助后期维护和接手的人去理解业务逻辑
  3. 可复用性
  4. 可拓展性
  5. 可维护性
  6. 代码的流行程度(这个是因为招人好不好招, 现在再去找个维护jQuery的, 很难了)
 
现在我觉得高质量代码:
  1. 可维护性 (important,重中之重)
  ....

+ **谁决定了工程代码的质量？**

> 这里可以用木桶理论来类比：木桶中的水位，不取决于最高的木板，而取决于最低的木板。同理，前端工程的质量，不取决于团队的平均能力，而取决于团队经验较少的技术同学的能力。在工作压力比较大的情况下，这些同学由于经验不足，短期又要完成需求，所以很多时候，并没有考虑过工程上的问题，而是直接面向实现功能编程，基本上我们现在面对的难以维护的代码，都是在这种条件下产生的。

> 我们当然可以寄希望于经验较少的同学通过不断的成长来提升项目的工程质量，但实践下来，这并不可行。原因在于，工程能力的积累需要大量的编码经验，缺少实践经验的问题并不是短期就能够迅速解决的，任何好的工程师都是在不断犯错学习的过程中成长起来的。同时，工程开发过程中很可能会遭遇人员变动，一个团队的成员不可能永远全部都是能力很强的。

> 那么我们就需要换一个策略来保障我们的代码质量，我们可以换个角度思考：是否可以通过一些规则，流程，编码上的约束，让编码能力不同的工程师，尽量写出质量相对较高的一致性代码。

我之前有段时间追求新技术,学习后,在公司去推.但是忽略了同事的接受性, 使用性,从而导致这个更加简洁的技术, 对于他们来说是一种负担.
所以选择最适合团队的技术, 才是最好的


+ **通过约束提升工程质量**

1. 约束让事情变得更简单
> 工作没有约束，工作中我们就难以形成共识，也无法判断工作做的好与坏。写代码也是一样的，没有约束，那么我们也无法判断代码是否合理。在流行的库和框架中，其实到处都是约束的影子，这里拿 Redux 和 React 的设计来举例:

> Redux 给出了单一数据源，State 只读，使用纯函数来执行修改这三个基本原则，同时要求通过 Action 的方式触发Reducer 的执行，这是 Redux 的约束；React 也给出了单向数据流这样的约束概念。

> 框架之所以是能够复用，能够得到推广，就是因为它们进行了封装，仅仅提供有限的约束能力供大家使用，这样大家才能形成一致的理念，编写互相能够读得懂的代码。理解了这一点，我们再来看业务工程的代码，实际上要提高开发效率和扩展性，无非也是要提供合理的约束。

> 工程代码的约束，更多带有一定的工程属性，如：

    1. 规定相同的请求地址只允许在 API 层出现一次（项目接口数目多，可减少代码冗余）
    2. 不使用超过 100 行以上的 Hook 代码（强化逻辑拆分，避免过度复杂的逻辑）
    3. 在复用性和可维护性上做选择时，优先选择可维护性（避免错误封装，封装代码中耦合大量逻辑判断）
    4. 业务代码注释覆盖率必须超过 10%（提升代码可读性，方便自动化生成文档）
    5. 项目中跨组件通信必须通过 Redux （降低组件传值代码的团队理解成本）
    6. 相同功能的 npm 包不允许安装多个（避免无用依赖安装，造成维护成本增加）
    7. 这些业务的约束，并不等同于 Eslint，不同的业务对代码的要求有可能千差万别，所以业务上的约束，需要研发人员充分的沟通交流，碰撞探讨，以及坚决执行。不同团队的同学，可能讨论出的结果完全不同，但约束的结论是什么本身不重要，重要的是形成一致的开发共识。

2. 通过机制实现约束的落地
> 约束本身并不难制定，对于工程侧的设计，工程师通过讨论比较容易形成博奕后的结论。但机制的落地是相对困难的一环。这里分享几个可执行的保障机制：

    1. CodeReview（每次CR，除了对业务进行逻辑分析，也需要将是否遵循约束作为审核的一环）
    2. 通过工具自动生成部分代码（比如使用脚手架生成工程代码中的某个模块，类似 AngularCLI 中 ng g component header 这样的指令，就可以帮你约束组件创建的代码结构）
    3. 配置化生成代码（通过配置，生成逻辑或者表单代码，建立配置项标准）
    4. 零代码 / PaaS 平台（通过平台生成代码，直接将用户与编码隔离，由平台保障生成代码的质量）
    5. 负责人机制（约束落地直接与绩效相关联，成为跟进明确指标）
    6. 沉淀文档（通过文档，沉淀约束机制）
    7. 通过这样的一些机制，保障约束有效的落地，那么我们就可以抹平团队成员技术能力的差异，形成一致性的编码风格。虽然这种约束下的代码并不一定是最优雅的代码，但至少工程质量不会差。所以这里我认为，约束实际上帮助我们保障的是工程质量的下限，那么接着我们来谈如何通过技术创新，提升工程质量的上限。

3. 在约束之上寻求创新
> 大家可能会有这样的问题：“项目的约束，会不会限制技术的创新”。针对短生命周期的小型项目，这可能是对的，这种项目，使用更多的新技术进行探索突破可能会带来更多的团队技术储备；但对于大型项目来说，我们每天所做的代码设计决策，都可能会影响到明天业务系统的发展进程，任何技术升级都一定要慎重，这时候，我们不应该把约束当作创新的阻碍，而应该把约束当作创新的练兵场。

> 如果你在大型项目中，想突破约束，使用新技术，进行技术革新，那么一定意味着你要做到以下几件事情：

    1. 对过去约束限制的背景有充分了解：背景没有改变，新技术是否能解决约束所解决的问题，同时不会带来新的问题
    2. 能够充分表述新技术所能够带来的价值：在形成共识的问题上，新技术是否能对性能，稳定性，体验，研发效率，业务提效有明显作用
    3. 能够给出技术升级的整体方案：在确认要进行技术升级时，你是否考虑到历史技术方案如何优雅的实现替换
    4. 能够说服团队认可新的技术升级方案：在当前已有技术的基础上，你是否能说服团队成员和你一同推进技术创新
    5. 能够带领团队或者自己将技术方案落地：你是否具备能力将新技术或者创新点完成落地
    6. 很多时候，我们做的技术创新，其实只是技术栈的更新，并没有为团队和业务侧带来任何的价值，但当我们想清楚这些问题，能够有信服力的证明新技术或者创新点是有价值的时候，关于系统的升级可能才是真正有价值的。

> 在约束上的创新，可以让工程师结合业务有更多的思考，产出真正有价值的创新。而这些有质量的思考和创新，决定了工程质量的上限， 同时也会培养出更多优秀的工程师。


距离2021年还有2天时间, 最近工作中遇到很多这一年遗留下来的事情,还是希望总结一下:
1. 当开发完成一个项目后, 一定一定要有始有终. 就例如: 4月份开发了一个项目, 但是现在年底才开始测试 , 看到8个月前的代码, 看到已经变化了的团队, 看到部分修改过字段的接口等等, 真的无从下手. 就算时间很紧, 也一定要跟产品项目进行协调
2. 确认产品的需求, 提出自己的意见. 以前我觉得能100%完成产品的需求就是好的 但是现在发现产品的天马行空的想法太过于..., 作为前后端一定要在技术方面提出建议, 哪怕是性能方面
3. 团队的良好沟通, 真的真的真的真的真的真的...很重要
4. 修改bug后 或 加需求后, 一定要测所有关联到的模块, 否则等于找死
5. 尽可能公平分配任务, 后期每个人维护自己的模块, 这样效率最高, 不要想着让团队成员帮你擦屁股
6. 希望产品更加强势一些. 如果同意修改模块后, 不要继续变来变去, 虽然改需求是合理的, 但是多了, 浪费时间.....
7. 在性能合理的情况下, 前端不要储存过多且复杂的数据, 特别是在vue项目里面, 再加上几个父祖孙组件之间互相传值, 分分钟钟想砸电脑
8. 过于复杂的数据 , 一定要后端配合
9. 在现在组件化, 工程化的大前端环境下, 传给后端的字段名是什么, 一定要后端一摸一样的返给你, 切记切记不要让后端牵着鼻子走, 要提出前端的合理需求
















